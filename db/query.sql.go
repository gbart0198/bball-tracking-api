// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createDrill = `-- name: CreateDrill :one
INSERT INTO drills (
    drill_name, category, difficulty
) VALUES (
    $1, $2, $3
)
RETURNING drill_id, drill_name, category, difficulty
`

type CreateDrillParams struct {
	DrillName  string      `json:"drillName"`
	Category   pgtype.Text `json:"category"`
	Difficulty pgtype.Text `json:"difficulty"`
}

func (q *Queries) CreateDrill(ctx context.Context, arg CreateDrillParams) (Drill, error) {
	row := q.db.QueryRow(ctx, createDrill, arg.DrillName, arg.Category, arg.Difficulty)
	var i Drill
	err := row.Scan(
		&i.DrillID,
		&i.DrillName,
		&i.Category,
		&i.Difficulty,
	)
	return i, err
}

const createPerformance = `-- name: CreatePerformance :one
INSERT INTO player_performances (
    player_id, drill_id, date, attempts, successful
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING player_performance_id, player_id, drill_id, date, attempts, successful
`

type CreatePerformanceParams struct {
	PlayerID   uuid.UUID   `json:"playerId"`
	DrillID    uuid.UUID   `json:"drillId"`
	Date       pgtype.Date `json:"date"`
	Attempts   pgtype.Int4 `json:"attempts"`
	Successful pgtype.Int4 `json:"successful"`
}

func (q *Queries) CreatePerformance(ctx context.Context, arg CreatePerformanceParams) (PlayerPerformance, error) {
	row := q.db.QueryRow(ctx, createPerformance,
		arg.PlayerID,
		arg.DrillID,
		arg.Date,
		arg.Attempts,
		arg.Successful,
	)
	var i PlayerPerformance
	err := row.Scan(
		&i.PlayerPerformanceID,
		&i.PlayerID,
		&i.DrillID,
		&i.Date,
		&i.Attempts,
		&i.Successful,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    username, passhash, email, firstname, lastname
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING user_id, username, passhash, email, firstname, lastname
`

type CreateUserParams struct {
	Username  string      `json:"username"`
	Passhash  string      `json:"passhash"`
	Email     string      `json:"email"`
	Firstname pgtype.Text `json:"firstname"`
	Lastname  pgtype.Text `json:"lastname"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.Passhash,
		arg.Email,
		arg.Firstname,
		arg.Lastname,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Passhash,
		&i.Email,
		&i.Firstname,
		&i.Lastname,
	)
	return i, err
}

const deleteDrill = `-- name: DeleteDrill :exec
DELETE FROM drills
WHERE drill_id = $1
`

func (q *Queries) DeleteDrill(ctx context.Context, drillID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDrill, drillID)
	return err
}

const deletePerformance = `-- name: DeletePerformance :exec
DELETE FROM player_performances
WHERE player_performance_id = $1
`

func (q *Queries) DeletePerformance(ctx context.Context, playerPerformanceID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePerformance, playerPerformanceID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE user_id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, userID)
	return err
}

const getDrill = `-- name: GetDrill :one
SELECT drill_id, drill_name, category, difficulty FROM drills
WHERE drill_id = $1 LIMIT 1
`

func (q *Queries) GetDrill(ctx context.Context, drillID uuid.UUID) (Drill, error) {
	row := q.db.QueryRow(ctx, getDrill, drillID)
	var i Drill
	err := row.Scan(
		&i.DrillID,
		&i.DrillName,
		&i.Category,
		&i.Difficulty,
	)
	return i, err
}

const getPerformance = `-- name: GetPerformance :one
SELECT player_performance_id, player_id, drill_id, date, attempts, successful from player_performances
WHERE player_performance_id = $1 LIMIT 1
`

func (q *Queries) GetPerformance(ctx context.Context, playerPerformanceID uuid.UUID) (PlayerPerformance, error) {
	row := q.db.QueryRow(ctx, getPerformance, playerPerformanceID)
	var i PlayerPerformance
	err := row.Scan(
		&i.PlayerPerformanceID,
		&i.PlayerID,
		&i.DrillID,
		&i.Date,
		&i.Attempts,
		&i.Successful,
	)
	return i, err
}

const getPerformancesByDrill = `-- name: GetPerformancesByDrill :many
SELECT 
    p.date,
    d.drill_id,
    d.drill_name,
    attempts,
    successful
FROM player_performances as p
JOIN drills as d on d.drill_id = p.drill_id
WHERE d.drill_id = $1
ORDER BY date desc
`

type GetPerformancesByDrillRow struct {
	Date       pgtype.Date `json:"date"`
	DrillID    uuid.UUID   `json:"drillId"`
	DrillName  string      `json:"drillName"`
	Attempts   pgtype.Int4 `json:"attempts"`
	Successful pgtype.Int4 `json:"successful"`
}

func (q *Queries) GetPerformancesByDrill(ctx context.Context, drillID uuid.UUID) ([]GetPerformancesByDrillRow, error) {
	rows, err := q.db.Query(ctx, getPerformancesByDrill, drillID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPerformancesByDrillRow
	for rows.Next() {
		var i GetPerformancesByDrillRow
		if err := rows.Scan(
			&i.Date,
			&i.DrillID,
			&i.DrillName,
			&i.Attempts,
			&i.Successful,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPerformancesByPlayer = `-- name: GetPerformancesByPlayer :many
SELECT 
    player_performance_id,
    u.username,
    d.drill_name,
    p.date,
    attempts,
    successful
FROM player_performances as p
JOIN users as u ON p.player_id = u.user_id 
JOIN drills as d on d.drill_id = p.drill_id
WHERE player_id = $1
ORDER BY date desc
`

type GetPerformancesByPlayerRow struct {
	PlayerPerformanceID uuid.UUID   `json:"playerPerformanceId"`
	Username            string      `json:"username"`
	DrillName           string      `json:"drillName"`
	Date                pgtype.Date `json:"date"`
	Attempts            pgtype.Int4 `json:"attempts"`
	Successful          pgtype.Int4 `json:"successful"`
}

func (q *Queries) GetPerformancesByPlayer(ctx context.Context, playerID uuid.UUID) ([]GetPerformancesByPlayerRow, error) {
	rows, err := q.db.Query(ctx, getPerformancesByPlayer, playerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPerformancesByPlayerRow
	for rows.Next() {
		var i GetPerformancesByPlayerRow
		if err := rows.Scan(
			&i.PlayerPerformanceID,
			&i.Username,
			&i.DrillName,
			&i.Date,
			&i.Attempts,
			&i.Successful,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT user_id, username, passhash, email, firstname, lastname from users
where user_id = $1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, userID uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUser, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Passhash,
		&i.Email,
		&i.Firstname,
		&i.Lastname,
	)
	return i, err
}

const listDrills = `-- name: ListDrills :many
SELECT drill_id, drill_name, category, difficulty from drills
ORDER BY drill_name asc
`

func (q *Queries) ListDrills(ctx context.Context) ([]Drill, error) {
	rows, err := q.db.Query(ctx, listDrills)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Drill
	for rows.Next() {
		var i Drill
		if err := rows.Scan(
			&i.DrillID,
			&i.DrillName,
			&i.Category,
			&i.Difficulty,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPerformance = `-- name: ListPerformance :many
SELECT player_performance_id, player_id, drill_id, date, attempts, successful from player_performances
ORDER BY date desc
`

func (q *Queries) ListPerformance(ctx context.Context) ([]PlayerPerformance, error) {
	rows, err := q.db.Query(ctx, listPerformance)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerPerformance
	for rows.Next() {
		var i PlayerPerformance
		if err := rows.Scan(
			&i.PlayerPerformanceID,
			&i.PlayerID,
			&i.DrillID,
			&i.Date,
			&i.Attempts,
			&i.Successful,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT user_id, username, passhash, email, firstname, lastname from users
ORDER BY username
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Passhash,
			&i.Email,
			&i.Firstname,
			&i.Lastname,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDrill = `-- name: UpdateDrill :exec
UPDATE drills
    SET drill_name = $2,
    category = $3,
    difficulty = $4
WHERE drill_id = $1
`

type UpdateDrillParams struct {
	DrillID    uuid.UUID   `json:"drillId"`
	DrillName  string      `json:"drillName"`
	Category   pgtype.Text `json:"category"`
	Difficulty pgtype.Text `json:"difficulty"`
}

func (q *Queries) UpdateDrill(ctx context.Context, arg UpdateDrillParams) error {
	_, err := q.db.Exec(ctx, updateDrill,
		arg.DrillID,
		arg.DrillName,
		arg.Category,
		arg.Difficulty,
	)
	return err
}

const updatePerformance = `-- name: UpdatePerformance :exec
UPDATE player_performances
    SET player_id = $2,
    drill_id = $3,
    date = $4,
    attempts = $5,
    successful = $6
WHERE player_performance_id = $1
`

type UpdatePerformanceParams struct {
	PlayerPerformanceID uuid.UUID   `json:"playerPerformanceId"`
	PlayerID            uuid.UUID   `json:"playerId"`
	DrillID             uuid.UUID   `json:"drillId"`
	Date                pgtype.Date `json:"date"`
	Attempts            pgtype.Int4 `json:"attempts"`
	Successful          pgtype.Int4 `json:"successful"`
}

func (q *Queries) UpdatePerformance(ctx context.Context, arg UpdatePerformanceParams) error {
	_, err := q.db.Exec(ctx, updatePerformance,
		arg.PlayerPerformanceID,
		arg.PlayerID,
		arg.DrillID,
		arg.Date,
		arg.Attempts,
		arg.Successful,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
    SET username = $2,
    passhash = $3,
    email = $4,
    firstname = $5,
    lastname = $6
WHERE user_id = $1
`

type UpdateUserParams struct {
	UserID    uuid.UUID   `json:"userId"`
	Username  string      `json:"username"`
	Passhash  string      `json:"passhash"`
	Email     string      `json:"email"`
	Firstname pgtype.Text `json:"firstname"`
	Lastname  pgtype.Text `json:"lastname"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.UserID,
		arg.Username,
		arg.Passhash,
		arg.Email,
		arg.Firstname,
		arg.Lastname,
	)
	return err
}
